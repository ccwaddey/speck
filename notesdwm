

Okay so we've got main. It calls checkotherwm(), setup(), scan() and
run(). Then it calls cleanup() and exits.

checkotherwm() basically just calls XSelectInput() with
SubstructureRedirectMask.

setup() gets the default screen of the display, the width and height,
and the root window. We create a drawable item (Drw struct) for the
root window. Do some stuff with monitors and the barpos in
updategeom(). Get some atoms in an array. Do some stuff with the
status bar. Do some stuff with properties. Set the root cursor. Set
the event mask for the root window. Grab the keyboard shortcut
keys. Set the focus to the root window.

scan() gets all the windows that are children of the root window and
calls manage on the ones that are either (transient and (viewable or
iconic)) or (not transient and not overriding and (viewable or
iconic)).

manage() creates a Client struct for the window. It stores the
geometry. It updates the title. It sets the monitor. It sets the
tags. It sets the border width.


Okay so the event mask for dwm on the root window is:

    SubstructureRedirectMask|SubstructureNotifyMask
    |ButtonPressMask|PointerMotionMask|EnterWindowMask
    |LeaveWindowMask|StructureNotifyMask|PropertyChangeMask,

and events types that we have handlers for are:

    ButtonPress, ClientMessage, ConfigureRequest, ConfigureNotify,
    DestroyNotify, EnterNotify, Expose, FocusIn, KeyPress, MappingNotify,
    MapRequest, MotionNotify, PropertyNotify, UnmapNotify.

SubstructureRedirectMask is a mask for the following events:

    CirculateRequest, ConfigureRequest, MapRequest.

SubstructureNotifyMask is a mask for these events:

    CirculateNotify, ConfigureNotify, CreateNotify, DestroyNotify,
    GravityNotify, MapNotify, ReparentNotify, UnmapNotify.

StructureNotifyMask is a mask for all the events of SubstructureNotifyMask
except CreateNotify.

The following events cannot be masked:

    ClientMessage, MappingNotify, SelectionClear, SelectionNotify,
    SelectionRequest.

Clients should run exactly the same with WMs as without, except that under a WM,
they should hint to the WM about the resources they want, accept the resources
they are given, and be prepared for those resources to change at any time.

So the only WM atoms that dwm uses are WM_PROTOCOLS, WM_DELETE_WINDOW, WM_STATE,
and WM_TAKE_FOCUS. If a client does not want to participate in any WM_PROTOCOLS,
then we will have to tell it to take focus with XSetInputFocus. Otherwise we'll
send a ClientMessageEvent.

The client properties in ICCCM are:

    don't care about: WM_NAME, WM_ICON_NAME, WM_CLASS, WM_COLORMAP_WINDOWS,
    	  WM_CLIENT_MACHINE; WM_ICON_SIZE

    care about: WM_NORMAL_HINTS, WM_HINTS, WM_TRANSIENT_FOR, WM_PROTOCOLS;
    	  WM_STATE.

The ones after the semicolon are set by us, others by the client. We have to
listen for ClientMessages to iconify. 